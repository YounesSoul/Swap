generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum RequestStatus {
  PENDING
  ACCEPTED
  DECLINED
  CANCELLED
  EXPIRED
}

enum SkillLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED
  EXPERT
}

model Skill {
  id        String      @id @default(uuid())
  name      String
  slug      String      @unique // lowercase for lookups
  createdAt DateTime    @default(now())
  users     UserSkill[]
}

model UserSkill {
  id        String     @id @default(uuid())
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  skill     Skill      @relation(fields: [skillId], references: [id], onDelete: Cascade)
  skillId   String
  level     SkillLevel @default(ADVANCED)
  createdAt DateTime   @default(now())

  @@unique([userId, skillId])
}

model UserCourse {
  id         String   @id @default(uuid())
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String
  courseCode String
  grade      String // store "A", "A+", etc.
  createdAt  DateTime @default(now())

  @@unique([userId, courseCode])
}

model UserInterest {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  type      String   // "skill" or "course"
  name      String   // skill name or course code
  createdAt DateTime @default(now())

  @@unique([userId, type, name])
  @@index([userId, type])
}

model User {
  id            String    @id @default(uuid())
  email         String    @unique
  name          String?
  firstName     String?
  lastName      String?
  dateOfBirth   DateTime?
  passwordHash  String?   @db.VarChar(255)
  image         String?
  emailVerified DateTime?
  university    String?
  timezone      String?
  createdAt     DateTime  @default(now())

  // NextAuth
  accounts     Account[]
  authSessions AuthSession[]

  // App relations
  requestsFrom      Request[]      @relation("RequestsFrom")
  requestsTo        Request[]      @relation("RequestsTo")
  sessionsAsTeacher Session[]      @relation("TeacherSessions")
  sessionsAsLearner Session[]      @relation("LearnerSessions")
  ledger            CreditLedger[]
  tokenLedger       TokenLedger[]

  // Chat
  threadsA ChatThread[] @relation("ThreadA")
  threadsB ChatThread[] @relation("ThreadB")
  messages Message[]

  isOnboarded Boolean      @default(false)
  userSkills  UserSkill[]
  userCourses UserCourse[]
  userInterests UserInterest[] // Learning interests/goals

  transcriptIngests TranscriptIngest[]

  // Ratings
  ratingsGiven    Rating[] @relation("RaterUser")
  ratingsReceived Rating[] @relation("RatedUser")
  
  // Reports
  reportsMade     Report[] @relation("ReporterUser")
  reportsReceived Report[] @relation("ReportedUser")

  // Availability
  timeSlots TimeSlot[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model AuthSession {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Request {
  id         String        @id @default(uuid())
  fromUser   User          @relation("RequestsFrom", fields: [fromUserId], references: [id])
  fromUserId String
  toUser     User          @relation("RequestsTo", fields: [toUserId], references: [id])
  toUserId   String
  courseCode String
  minutes    Int
  note       String?
  status     RequestStatus @default(PENDING)

  // one-to-one to Session (when accepted)
  sessionId String?  @unique
  session   Session? @relation("RequestToSession", fields: [sessionId], references: [id])

  // Link to requested time slot (optional - for timeslot-based bookings)
  timeSlot   TimeSlot? @relation(fields: [timeSlotId], references: [id])
  timeSlotId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([toUserId, status])
  @@index([fromUserId, status])
}

model Session {
  id          String         @id @default(uuid())
  teacher     User           @relation("TeacherSessions", fields: [teacherId], references: [id])
  teacherId   String
  learner     User           @relation("LearnerSessions", fields: [learnerId], references: [id])
  learnerId   String
  courseCode  String
  minutes     Int
  status      String         @default("scheduled")
  startAt     DateTime?
  endAt       DateTime?
  createdAt   DateTime       @default(now())
  ledger      CreditLedger[]
  tokens      TokenLedger[]

  // Link to booked time slot
  timeSlot    TimeSlot? @relation(fields: [timeSlotId], references: [id])
  timeSlotId  String?
  
  // Session delivery mode and meeting info
  sessionType SessionType?   // inherited from TimeSlot
  meetingLink String?        // Zoom link for online sessions

  request Request? @relation("RequestToSession")
  ratings Rating[]
  reports Report[]
}

model CreditLedger {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  session   Session? @relation(fields: [sessionId], references: [id])
  sessionId String?
  delta     Int
  reason    String
  createdAt DateTime @default(now())
}

model TokenLedger {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  session   Session? @relation(fields: [sessionId], references: [id])
  sessionId String?
  tokens    Int
  reason    String
  createdAt DateTime @default(now())
}

//// CHAT ////

model ChatThread {
  id             String    @id @default(uuid())
  participantA   User      @relation("ThreadA", fields: [participantAId], references: [id])
  participantAId String
  participantB   User      @relation("ThreadB", fields: [participantBId], references: [id])
  participantBId String
  createdAt      DateTime  @default(now())
  messages       Message[]

  // enforce one thread per unordered pair
  @@unique([participantAId, participantBId], name: "pair_unique")
}

model Message {
  id        String     @id @default(uuid())
  thread    ChatThread @relation(fields: [threadId], references: [id])
  threadId  String
  sender    User       @relation(fields: [senderId], references: [id])
  senderId  String
  text      String
  createdAt DateTime   @default(now())
  readAt    DateTime?

  @@index([threadId, createdAt])
}

model TranscriptIngest {
  id         String   @id @default(uuid())
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String
  fileName   String
  fileHash   String
  parsedJson Json
  addedCount Int
  createdAt  DateTime @default(now())

  @@index([userId, createdAt])
}

//// RATINGS ////

model Rating {
  id          String   @id @default(uuid())
  rater       User     @relation("RaterUser", fields: [raterId], references: [id], onDelete: Cascade)
  raterId     String
  rated       User     @relation("RatedUser", fields: [ratedId], references: [id], onDelete: Cascade)
  ratedId     String
  session     Session? @relation(fields: [sessionId], references: [id], onDelete: SetNull)
  sessionId   String?
  rating      Int      // 1-5 stars
  review      String?  // optional text review
  category    String   // "skill" or "course"
  skillOrCourse String // skill name or course code
  createdAt   DateTime @default(now())
  
  @@unique([raterId, ratedId, sessionId])
  @@index([ratedId, category])
  @@index([ratedId, createdAt])
}

//// REPORTS ////

model Report {
  id          String   @id @default(uuid())
  reporter    User     @relation("ReporterUser", fields: [reporterId], references: [id], onDelete: Cascade)
  reporterId  String
  reported    User     @relation("ReportedUser", fields: [reportedId], references: [id], onDelete: Cascade)
  reportedId  String
  session     Session? @relation(fields: [sessionId], references: [id], onDelete: SetNull)
  sessionId   String?
  reason      String   // reason for the report
  description String?  // optional detailed description
  status      String   @default("pending") // pending, reviewed, resolved
  createdAt   DateTime @default(now())
  
  @@index([reportedId, status])
  @@index([createdAt])
}

//// TIME SLOTS (AVAILABILITY) ////

enum DayOfWeek {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

enum SessionType {
  ONLINE
  FACE_TO_FACE
}

model TimeSlot {
  id          String      @id @default(uuid())
  teacher     User        @relation(fields: [teacherId], references: [id], onDelete: Cascade)
  teacherId   String
  
  // What is being taught
  type        String      // "course" or "skill"
  courseCode  String?     // if type = "course"
  skillName   String?     // if type = "skill"
  
  // When (recurring weekly)
  dayOfWeek   DayOfWeek
  startTime   String      // HH:MM format (e.g., "14:00")
  endTime     String      // HH:MM format (e.g., "16:00")
  
  // How (delivery mode)
  sessionType SessionType @default(ONLINE) // online or face-to-face
  
  // Status
  isActive    Boolean     @default(true) // teacher can deactivate without deleting
  
  // Bookings
  sessions    Session[]
  requests    Request[]   // Requests for this time slot
  
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  
  @@index([teacherId, type, isActive])
  @@index([type, courseCode])
  @@index([type, skillName])
}
